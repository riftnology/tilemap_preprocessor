KonvaJS Documentation - Complete Reference

==================================================


AI tools - KonvaJS Documentation
================================

Source: https://konvajs.org/docs/ai_tools.html

Coding with Konva and AI agent​ We have several AI tools that may help you build better konva apps. All of them are powered by awesome crawlchat. AI agent will use Konva docs exensevly to answer your questions. Please remember it is an LLM and as any modern LLM it may give wrong answers. AI chat bot​ Click "Ask AI" button somewhere on the page to ask a question to AI. You can also join your Discord community and ask @AiBot-CrawlChat there. MCP​ MCP (Model Context Protocol) is a standard protocol to connect with LLM applications like Claude App, Cursor, Windsurf or more such applications. Cursor MCP Command​ For clear video instructions take a look into this guide. Cursor needs a JSON snippet to be added to the Cursor settings. Copy and paste the following snippet. Important: as of March 2025, cursor will use MCP only in "Agent" mode. "Ask" and others will not use it. "konva-documentation": { "command": "npx", "args": [ "crawl-chat-mcp", "--id=67d221efb4b9de65095a2579", "--name=konva_documentation" ]} MCP Command​ npx crawl-chat-mcp --id=67d221efb4b9de65095a2579 --name=konva_documentation

================================================================================


Animations - KonvaJS Documentation
==================================

Source: https://konvajs.org/docs/animations/Create_an_Animation.html

To create custom animations with Konva, we can use the Konva.Animation constructor which takes two arguments, the required update function and an optional layer, or array of layers, that will be updated with each animation frame. The animation function is passed a frame object which contains a time property which is the number of milliseconds that the animation has been running, a timeDiff property which is the number of milliseconds that have passed since the last frame, and a frameRate property which is the current frame rate in frames per second. The update function should never redraw the stage or a layer because the animation engine will intelligently handle that for us. The update function should only contain logic that updates Node properties, such as position, rotation, scale, width, height, radius, colors, etc. Once the animation has been created, we can start it at anytime with the start() method. For a full list of attributes and methods, check out the Konva.Animation documentation. VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; const stage = new Konva.Stage({ container: 'container', width: window.innerWidth, height: window.innerHeight, }); const layer = new Konva.Layer(); stage.add(layer); const rect = new Konva.Rect({ x: 50, y: 50, width: 50, height: 50, fill: 'green', }); layer.add(rect); const anim = new Konva.Animation(function(frame) { const time = frame.time; const timeDiff = frame.timeDiff; const frameRate = frame.frameRate; // Example: move rectangle in a circle const radius = 50; const x = radius * Math.cos(frame.time * 2 * Math.PI / 2000) + 100; const y = radius * Math.sin(frame.time * 2 * Math.PI / 2000) + 100; rect.position({ x, y }); }, layer); anim.start(); Open on CodeSandboxOpen Sandboximport { Stage, Layer, Rect } from 'react-konva'; import { useEffect, useRef } from 'react'; const App = () => { const rectRef = useRef(null); useEffect(() => { const anim = new Konva.Animation((frame) => { const time = frame.time; const timeDiff = frame.timeDiff; const frameRate = frame.frameRate; // Example: move rectangle in a circle const radius = 50; const x = radius * Math.cos(frame.time * 2 * Math.PI / 2000) + 100; const y = radius * Math.sin(frame.time * 2 * Math.PI / 2000) + 100; rectRef.current.position({ x, y }); }, rectRef.current.getLayer()); anim.start(); return () => { anim.stop(); }; }, []); return ( <Stage width={window.innerWidth} height={window.innerHeight}> <Layer> <Rect ref={rectRef} x={50} y={50} width={50} height={50} fill="green" /> </Layer> </Stage> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <v-stage :config="stageSize"> <v-layer ref="layerRef"> <v-rect ref="rectRef" :config="rectConfig" /> </v-layer> </v-stage> </template> <script setup> import { ref, onMounted, onUnmounted } from 'vue'; import Konva from 'konva'; const stageSize = { width: window.innerWidth, height: window.innerHeight }; const rectConfig = ref({ x: 50, y: 50, width: 50, height: 50, fill: 'green' }); const layerRef = ref(null); const rectRef = ref(null); let anim = null; onMounted(() => { anim = new Konva.Animation((frame) => { const time = frame.time; const timeDiff = frame.timeDiff; const frameRate = frame.frameRate; // Example: move rectangle in a circle const radius = 50; const x = radius * Math.cos(frame.time * 2 * Math.PI / 2000) + 100; const y = radius * Math.sin(frame.time * 2 * Math.PI / 2000) + 100; rectRef.value.getNode().position({ x, y }); }, layerRef.value.getNode()); anim.start(); }); onUnmounted(() => { if (anim) { anim.stop(); } }); </script> Open on CodeSandboxOpen Sandbox

================================================================================


Clipping - KonvaJS Documentation
================================

Source: https://konvajs.org/docs/clipping/Clipping_Function.html

How to clip nodes in the layer?​ To draw things inside of complex clipping regions with Konva, we can set the clipFunc property of a group, a layer. In this tutorial, we'll draw blobs inside of a two circles clipping region applied to a group. VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; // First we need to create stage const stage = new Konva.Stage({ container: 'container', width: window.innerWidth, height: window.innerHeight, }); // Then create layer const layer = new Konva.Layer(); const group = new Konva.Group({ clipFunc: function (ctx) { ctx.beginPath(); ctx.arc(200, 120, 50, 0, Math.PI * 2, false); ctx.arc(280, 120, 50, 0, Math.PI * 2, false); }, }); for (let i = 0; i < 20; i++) { const blob = new Konva.Circle({ x: Math.random() * stage.width(), y: Math.random() * stage.height(), radius: Math.random() * 50, fill: 'green', opacity: 0.8, }); group.add(blob); } // add the shape to the layer layer.add(group); // add the layer to the stage stage.add(layer); Open on CodeSandboxOpen Sandboximport { Stage, Layer, Group, Circle } from 'react-konva'; const App = () => { const blobs = Array.from({ length: 20 }, (_, i) => ({ x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight, radius: Math.random() * 50, })); return ( <Stage width={window.innerWidth} height={window.innerHeight}> <Layer> <Group clipFunc={(ctx) => { ctx.beginPath(); ctx.arc(200, 120, 50, 0, Math.PI * 2, false); ctx.arc(280, 120, 50, 0, Math.PI * 2, false); }} > {blobs.map((blob, i) => ( <Circle key={i} x={blob.x} y={blob.y} radius={blob.radius} fill="green" opacity={0.8} /> ))} </Group> </Layer> </Stage> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <v-stage :config="stageSize"> <v-layer> <v-group :config="groupConfig"> <v-circle v-for="(blob, i) in blobs" :key="i" :config="blob" /> </v-group> </v-layer> </v-stage> </template> <script setup> const stageSize = { width: window.innerWidth, height: window.innerHeight }; const groupConfig = { clipFunc: (ctx) => { ctx.beginPath(); ctx.arc(200, 120, 50, 0, Math.PI * 2, false); ctx.arc(280, 120, 50, 0, Math.PI * 2, false); } }; const blobs = Array.from({ length: 20 }, () => ({ x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight, radius: Math.random() * 50, fill: 'green', opacity: 0.8 })); </script> Open on CodeSandboxOpen Sandbox

================================================================================


Data and Serialization - KonvaJS Documentation
==============================================

Source: https://konvajs.org/docs/data_and_serialization/Best_Practices.html

What is the best way to save/load full stage content and how to implement undo/redo?​ If you want to save/load simple canvas content you can use the built-in Konva methods: node.toJSON() and Node.create(json). See simple and complex demos. But those methods are useful only in very small apps. In bigger apps it is VERY hard to use those methods. Why? Because the tree structure is usually very complex in larger apps, you may have a lot of event listeners, images, filters, etc. That data is not serializable into JSON (or it is very hard to do that). Also it is very common that nodes in a tree have a lot information that is not directly related to the state of your app, but just used to describe visual view of your app. For instance, let's think we have a game, that draws several balls in canvas. The balls are not just circles, but the complex visual groups of objects with shadows and texts inside them (like "Made in China"). Now let's think you want to serialize state of your app and use it somewhere else. Like send to another computer or implement undo/redo. Almost all the visual information (shadows, texts, sizes) is not critical and may be you don't need to save it. Because all balls have the same shadows, sizes, etc. But what is critical? In that case it is just a number of balls and their coordinates. You need to save/load only that information. It will be just a simple array: var state = [{x: 10, y: 10}, { x: 160, y: 1041}] Now when you have that information, you need to have a function, that can create the whole canvas structure. If you want to update your canvas, for instance, you want to create a new ball, you don't need to create a new canvas node directly (like creating new instance of Konva.Circle), you just need to push a new object into a state and update (or recreate) canvas. In that case you don't need to care about image loading, filters, event listeners, etc in saving/loading phases. Because you do all these actions in your create or update functions. You would better understand what I am talking about if you know how many modern frameworks work (like React, Vue, Angular and many other). Also take a look into these demos to have a better idea: Undo/redo with react Save/load with Vue How to implement that create and update functions? It depends. From my point of view it will be easier to use frameworks that can do that job for you, like react-konva. If you don't want to use such frameworks you need to think in terms of your own app. Here I will try to make a small demo to give you an idea. The super naive method is to implement just one function create(state) that will do all the complex job of loading. If you have some changes in your app you just need to destroy the canvas and create a new one. But the drawback of such approach is possibly a bad performance. A bit smarter implementation is to create two functions create(state) and update(state). create will make instances of all required objects, attach events and load images. update will update properties of nodes. If number of objects is changed - destroy all and create from scratch. If only some properties changed - call update. Instructions: In that demo we will have a bunch of images with filters, and you can add more, move them, apply a new filter by clicking on images and use undo/redo. VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; // Initial state let state = { images: [ { x: 50, y: 50, filter: 'none' }, { x: 150, y: 50, filter: 'blur' } ] }; // History for undo/redo const history = [JSON.stringify(state)]; let historyStep = 0; const stage = new Konva.Stage({ container: 'container', width: window.innerWidth, height: window.innerHeight, }); const layer = new Konva.Layer(); stage.add(layer); // Create container const container = document.createElement('div'); container.style.position = 'relative'; document.body.appendChild(container); // Create button container const buttonContainer = document.createElement('div'); buttonContainer.style.position = 'absolute'; buttonContainer.style.top = '10px'; buttonContainer.style.left = '10px'; buttonContainer.style.zIndex = '10'; container.appendChild(buttonContainer); // Create UI buttons const addButton = document.createElement('button'); addButton.textContent = 'Add Image'; addButton.style.margin = '0 5px'; buttonContainer.appendChild(addButton); const undoButton = document.createElement('button'); undoButton.textContent = 'Undo'; undoButton.style.margin = '0 5px'; buttonContainer.appendChild(undoButton); const redoButton = document.createElement('button'); redoButton.textContent = 'Redo'; redoButton.style.margin = '0 5px'; buttonContainer.appendChild(redoButton); // Move stage container into our container const stageContainer = document.getElementById('container'); container.appendChild(stageContainer); stageContainer.style.position = 'absolute'; stageContainer.style.top = '0'; stageContainer.style.left = '0'; // Load image const imageObj = new Image(); imageObj.src = 'https://konvajs.org/assets/lion.png'; function createImage(imageConfig) { const image = new Konva.Image({ image: imageObj, x: imageConfig.x, y: imageConfig.y, width: 100, height: 100, draggable: true }); if (imageConfig.filter === 'blur') { image.filters([Konva.Filters.Blur]); image.blurRadius(10); } return image; } function create(state) { layer.destroyChildren(); state.images.forEach(imgConfig => { const image = createImage(imgConfig); image.on('dragend', () => { const pos = image.position(); const index = layer.children.indexOf(image); state.images[index] = { ...state.images[index], x: pos.x, y: pos.y }; saveHistory(); }); image.on('click', () => { const index = layer.children.indexOf(image); state.images[index] = { ...state.images[index], filter: state.images[index].filter === 'none' ? 'blur' : 'none' }; saveHistory(); create(state); }); layer.add(image); }); } function saveHistory() { historyStep++; history.length = historyStep; history.push(JSON.stringify(state)); } // Add event listeners addButton.addEventListener('click', () => { state.images.push({ x: Math.random() * stage.width(), y: Math.random() * stage.height(), filter: 'none' }); saveHistory(); create(state); }); undoButton.addEventListener('click', () => { if (historyStep === 0) return; historyStep--; state = JSON.parse(history[historyStep]); create(state); }); redoButton.addEventListener('click', () => { if (historyStep === history.length - 1) return; historyStep++; state = JSON.parse(history[historyStep]); create(state); }); imageObj.onload = () => { create(state); }; Open on CodeSandboxOpen Sandboximport { Stage, Layer, Image } from 'react-konva'; import { useState, useEffect } from 'react'; import useImage from 'use-image'; const App = () => { const [images, setImages] = useState([ { x: 50, y: 50, filter: 'none' }, { x: 150, y: 50, filter: 'blur' } ]); const [history, setHistory] = useState([]); const [historyStep, setHistoryStep] = useState(0); const [lionImage] = useImage('https://konvajs.org/assets/lion.png', 'anonymous'); useEffect(() => { if (lionImage) { setHistory([JSON.stringify(images)]); } }, [lionImage]); const handleDragEnd = (index, e) => { const newImages = [...images]; newImages[index] = { ...newImages[index], x: e.target.x(), y: e.target.y() }; setImages(newImages); saveHistory(newImages); }; const handleClick = (index) => { const newImages = [...images]; newImages[index] = { ...newImages[index], filter: newImages[index].filter === 'none' ? 'blur' : 'none' }; setImages(newImages); saveHistory(newImages); }; const saveHistory = (newImages) => { const newHistory = history.slice(0, historyStep + 1); newHistory.push(JSON.stringify(newImages)); setHistory(newHistory); setHistoryStep(newHistory.length - 1); }; const handleAdd = () => { const newImages = [...images, { x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight, filter: 'none' }]; setImages(newImages); saveHistory(newImages); }; const handleUndo = () => { if (historyStep === 0) return; const newStep = historyStep - 1; setHistoryStep(newStep); setImages(JSON.parse(history[newStep])); }; const handleRedo = () => { if (historyStep === history.length - 1) return; const newStep = historyStep + 1; setHistoryStep(newStep); setImages(JSON.parse(history[newStep])); }; return ( <div style={{ position: 'relative' }}> <div style={{ position: 'absolute', top: 10, left: 10, zIndex: 10 }}> <button style={{ margin: '0 5px' }} onClick={handleAdd}>Add Image</button> <button style={{ margin: '0 5px' }} onClick={handleUndo}>Undo</button> <button style={{ margin: '0 5px' }} onClick={handleRedo}>Redo</button> </div> <Stage width={window.innerWidth} height={window.innerHeight}> <Layer> {lionImage && images.map((img, i) => ( <Image key={i} image={lionImage} x={img.x} y={img.y} width={100} height={100} draggable filters={img.filter === 'blur' ? [Konva.Filters.Blur] : []} blurRadius={img.filter === 'blur' ? 10 : 0} onDragEnd={(e) => handleDragEnd(i, e)} onClick={() => handleClick(i)} /> ))} </Layer> </Stage> </div> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <div style="position: relative"> <div style="position: absolute; top: 10px; left: 10px; z-index: 10"> <button style="margin: 0 5px" @click="handleAdd">Add Image</button> <button style="margin: 0 5px" @click="handleUndo">Undo</button> <button style="margin: 0 5px" @click="handleRedo">Redo</button> </div> <v-stage :config="stageSize"> <v-layer> <v-image v-for="(img, i) in images" :key="i" :config="getImageConfig(img)" @dragend="handleDragEnd(i, $event)" @click="handleClick(i)" /> </v-layer> </v-stage> </div> </template> <script setup> import { ref, computed } from 'vue'; import Konva from 'konva'; import { useImage } from 'vue-konva'; const stageSize = { width: window.innerWidth, height: window.innerHeight }; const images = ref([ { x: 50, y: 50, filter: 'none' }, { x: 150, y: 50, filter: 'blur' } ]); const history = ref([]); const historyStep = ref(0); const [lionImage] = useImage('https://konvajs.org/assets/lion.png', 'anonymous'); const getImageConfig = (img) => ({ image: lionImage.value, x: img.x, y: img.y, width: 100, height: 100, draggable: true, filters: img.filter === 'blur' ? [Konva.Filters.Blur] : [], blurRadius: img.filter === 'blur' ? 10 : 0 }); const saveHistory = (newImages) => { const newHistory = history.value.slice(0, historyStep.value + 1); newHistory.push(JSON.stringify(newImages)); history.value = newHistory; historyStep.value = newHistory.length - 1; }; const handleDragEnd = (index, e) => { const newImages = [...images.value]; const pos = e.target.position(); newImages[index] = { ...newImages[index], x: pos.x, y: pos.y }; images.value = newImages; saveHistory(newImages); }; const handleClick = (index) => { const newImages = [...images.value]; newImages[index] = { ...newImages[index], filter: newImages[index].filter === 'none' ? 'blur' : 'none' }; images.value = newImages; saveHistory(newImages); }; const handleAdd = () => { const newImages = [...images.value, { x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight, filter: 'none' }]; images.value = newImages; saveHistory(newImages); }; const handleUndo = () => { if (historyStep.value === 0) return; historyStep.value--; images.value = JSON.parse(history.value[historyStep.value]); }; const handleRedo = () => { if (historyStep.value === history.value.length - 1) return; historyStep.value++; images.value = JSON.parse(history.value[historyStep.value]); }; // Initialize history when image is loaded if (lionImage.value) { history.value = [JSON.stringify(images.value)]; } </script> Open on CodeSandboxOpen Sandbox

================================================================================


Demos - KonvaJS Documentation
=============================

Source: https://konvajs.org/docs/sandbox/10000_Shapes_with_Tooltip.html

This demo shows how to handle a large number of shapes (10,000 circles) with tooltips efficiently. When you hover over any circle, a tooltip will show its index and color. VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; const width = window.innerWidth; const height = window.innerHeight; const stage = new Konva.Stage({ container: 'container', width: width, height: height, }); const circlesLayer = new Konva.Layer(); const tooltipLayer = new Konva.Layer(); const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'cyan', 'purple']; let colorIndex = 0; for (let i = 0; i < 10000; i++) { const color = colors[colorIndex++]; if (colorIndex >= colors.length) { colorIndex = 0; } const randX = Math.random() * stage.width(); const randY = Math.random() * stage.height(); const circle = new Konva.Circle({ x: randX, y: randY, radius: 3, fill: color, name: i.toString(), }); circlesLayer.add(circle); } const tooltip = new Konva.Text({ text: '', fontFamily: 'Calibri', fontSize: 12, padding: 5, visible: false, fill: 'black', opacity: 0.75, }); tooltipLayer.add(tooltip); stage.add(circlesLayer); stage.add(tooltipLayer); circlesLayer.on('mousemove', (e) => { const mousePos = stage.getPointerPosition(); tooltip.position({ x: mousePos.x + 5, y: mousePos.y + 5, }); tooltip.text('node: ' + e.target.name() + ', color: ' + e.target.fill()); tooltip.show(); }); circlesLayer.on('mouseout', () => { tooltip.hide(); }); Open on CodeSandboxOpen Sandboximport React from 'react'; import { Stage, Layer, Circle, Text } from 'react-konva'; const App = () => { const [tooltipProps, setTooltipProps] = React.useState({ text: '', visible: false, x: 0, y: 0 }); const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'cyan', 'purple']; const circles = React.useMemo(() => { const items = []; let colorIndex = 0; for (let i = 0; i < 10000; i++) { const color = colors[colorIndex++]; if (colorIndex >= colors.length) { colorIndex = 0; } items.push({ id: i, x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight, color }); } return items; }, []); const handleMouseMove = (e) => { const mousePos = e.target.getStage().getPointerPosition(); setTooltipProps({ text: `node: ${e.target.name()}, color: ${e.target.attrs.fill}`, visible: true, x: mousePos.x + 5, y: mousePos.y + 5 }); }; const handleMouseOut = () => { setTooltipProps(prev => ({ ...prev, visible: false })); }; return ( <Stage width={window.innerWidth} height={window.innerHeight}> <Layer onMouseMove={handleMouseMove} onMouseOut={handleMouseOut}> {circles.map(({ id, x, y, color }) => ( <Circle key={id} x={x} y={y} radius={3} fill={color} name={id.toString()} /> ))} </Layer> <Layer> <Text {...tooltipProps} fontFamily="Calibri" fontSize={12} padding={5} fill="black" opacity={0.75} /> </Layer> </Stage> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <v-stage :config="stageSize"> <v-layer @mousemove="handleMouseMove" @mouseout="handleMouseOut"> <v-circle v-for="circle in circles" :key="circle.id" :config="{ x: circle.x, y: circle.y, radius: 3, fill: circle.color, name: circle.id.toString() }" /> </v-layer> <v-layer> <v-text :config="{ ...tooltipProps, fontFamily: 'Calibri', fontSize: 12, padding: 5, fill: 'black', opacity: 0.75, textFill: 'white' }" /> </v-layer> </v-stage> </template> <script setup> import { ref, computed } from 'vue'; const stageSize = { width: window.innerWidth, height: window.innerHeight }; const tooltipProps = ref({ text: '', visible: false, x: 0, y: 0 }); const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'cyan', 'purple']; const circles = computed(() => { const items = []; let colorIndex = 0; for (let i = 0; i < 10000; i++) { const color = colors[colorIndex++]; if (colorIndex >= colors.length) { colorIndex = 0; } items.push({ id: i, x: Math.random() * stageSize.width, y: Math.random() * stageSize.height, color }); } return items; }); const handleMouseMove = (e) => { const mousePos = e.target.getStage().getPointerPosition(); tooltipProps.value = { text: `node: ${e.target.name()}, color: ${e.target.attrs.fill}`, visible: true, x: mousePos.x + 5, y: mousePos.y + 5 }; }; const handleMouseOut = () => { tooltipProps.value.visible = false; }; </script> Open on CodeSandboxOpen Sandbox

================================================================================


Donate - KonvaJS Documentation
==============================

Source: https://konvajs.org/docs/donate.html

On this pageHello, my name is Anton. I am core maintainer of Konva framework. If you want to support development of Konva and all its ecosystem tools like react-konva and vue-konva you can use: Patreon Open Collective GitHub Sponsor I am spending a large amount of time to support Konva users and develop new versions with bugs fixes and new features. If you are making money, by using Konva in your project, it makes sense to support Konva development. By doing this you will make sure that you have a good quality and maintained framework. Even if you are not making money from your project but Konva saved you a lot of time, it will be very kind to support it. Your company is using Konva?​ It may be hard for many developers to make a financial donation. But if you are using konva as part of your work in the company, talk to your managers to support the project. Well-supported project is a good value for the company.

================================================================================


Drag and Drop - KonvaJS Documentation
=====================================

Source: https://konvajs.org/docs/drag_and_drop/Drag_and_Drop.html

To drag and drop shapes with Konva, we can set the draggable property to true when we instantiate a shape, or we can use the draggable() method. The draggable() method enables drag and drop for both desktop and mobile applications automatically. To detect drag and drop events with Konva, we can use the on() method to bind dragstart, dragmove, or dragend events to a node. The on() method requires an event type and a function to be executed when the event occurs. VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; const stage = new Konva.Stage({ container: 'container', width: window.innerWidth, height: window.innerHeight, }); const layer = new Konva.Layer(); stage.add(layer); const circle = new Konva.Circle({ x: stage.width() / 2, y: stage.height() / 2, radius: 70, fill: 'red', stroke: 'black', strokeWidth: 4, draggable: true, }); // add cursor styling circle.on('mouseover', function () { document.body.style.cursor = 'pointer'; }); circle.on('mouseout', function () { document.body.style.cursor = 'default'; }); layer.add(circle); Open on CodeSandboxOpen Sandboximport { Stage, Layer, Circle } from 'react-konva'; import { useState } from 'react'; const App = () => { const [position, setPosition] = useState({ x: window.innerWidth / 2, y: window.innerHeight / 2 }); return ( <Stage width={window.innerWidth} height={window.innerHeight}> <Layer> <Circle x={position.x} y={position.y} radius={70} fill="red" stroke="black" strokeWidth={4} draggable onMouseEnter={(e) => { document.body.style.cursor = 'pointer'; }} onMouseLeave={(e) => { document.body.style.cursor = 'default'; }} onDragEnd={(e) => { setPosition({ x: e.target.x(), y: e.target.y() }); }} /> </Layer> </Stage> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <v-stage :config="stageSize"> <v-layer> <v-circle :config="circleConfig" @mouseenter="handleMouseEnter" @mouseleave="handleMouseLeave" /> </v-layer> </v-stage> </template> <script setup> const stageSize = { width: window.innerWidth, height: window.innerHeight }; const circleConfig = { x: window.innerWidth / 2, y: window.innerHeight / 2, radius: 70, fill: 'red', stroke: 'black', strokeWidth: 4, draggable: true }; const handleMouseEnter = () => { document.body.style.cursor = 'pointer'; }; const handleMouseLeave = () => { document.body.style.cursor = 'default'; }; </script> Open on CodeSandboxOpen Sandbox

================================================================================


Events - KonvaJS Documentation
==============================

Source: https://konvajs.org/docs/events/Binding_Events.html

To detect shape events with Konva, we can use the on() method to bind event handlers to a node. The on() method requires an event type and a function to be executed when the event occurs. Mouse events: mouseover, mouseout, mouseenter, mouseleave, mousemove, mousedown, mouseup, wheel, click, dblclick. Touch events: touchstart, touchmove, touchend, tap, dbltap. Pointer events: pointerdown, pointermove, pointereup, pointercancel, pointerover, pointerenter, pointerout,pointerleave, pointerclick, pointerdblclick. Drag events: dragstart, dragmove, and dragend. Transform events: transformstart, transform, transformend. Instructions: Mouseover and mouseout of the triangle, and mouseover, mouseout, mousedown, and mouseup over the circle. VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; const stage = new Konva.Stage({ container: 'container', width: window.innerWidth, height: window.innerHeight, }); const layer = new Konva.Layer(); const text = new Konva.Text({ x: 10, y: 10, fontFamily: 'Calibri', fontSize: 24, text: '', fill: 'black', }); const triangle = new Konva.RegularPolygon({ x: 80, y: 120, sides: 3, radius: 80, fill: '#00D2FF', stroke: 'black', strokeWidth: 4, }); const circle = new Konva.Circle({ x: 230, y: 100, radius: 60, fill: 'red', stroke: 'black', strokeWidth: 4, }); function writeMessage(message) { text.text(message); } triangle.on('mouseout', () => { writeMessage('Mouseout triangle'); }); triangle.on('mousemove', () => { const mousePos = stage.getPointerPosition(); writeMessage('x: ' + mousePos.x + ', y: ' + mousePos.y); }); circle.on('mouseover', () => { writeMessage('Mouseover circle'); }); circle.on('mouseout', () => { writeMessage('Mouseout circle'); }); circle.on('mousedown', () => { writeMessage('Mousedown circle'); }); circle.on('mouseup', () => { writeMessage('Mouseup circle'); }); layer.add(triangle); layer.add(circle); layer.add(text); stage.add(layer); Open on CodeSandboxOpen Sandboximport { Stage, Layer, RegularPolygon, Circle, Text } from 'react-konva'; import { useRef, useState } from 'react'; const App = () => { const [message, setMessage] = useState(''); const stageRef = useRef(); const writeMessage = (text) => { setMessage(text); }; return ( <Stage width={window.innerWidth} height={window.innerHeight} ref={stageRef}> <Layer> <Text x={10} y={10} fontFamily="Calibri" fontSize={24} text={message} fill="black" /> <RegularPolygon x={80} y={120} sides={3} radius={80} fill="#00D2FF" stroke="black" strokeWidth={4} onMouseout={() => writeMessage('Mouseout triangle')} onMousemove={() => { const mousePos = stageRef.current.getPointerPosition(); writeMessage('x: ' + mousePos.x + ', y: ' + mousePos.y); }} /> <Circle x={230} y={100} radius={60} fill="red" stroke="black" strokeWidth={4} onMouseover={() => writeMessage('Mouseover circle')} onMouseout={() => writeMessage('Mouseout circle')} onMousedown={() => writeMessage('Mousedown circle')} onMouseup={() => writeMessage('Mouseup circle')} /> </Layer> </Stage> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <v-stage :config="stageSize" ref="stageRef"> <v-layer> <v-text :config="textConfig" /> <v-regular-polygon :config="triangleConfig" @mouseout="writeMessage('Mouseout triangle')" @mousemove="handleTriangleMouseMove" /> <v-circle :config="circleConfig" @mouseover="writeMessage('Mouseover circle')" @mouseout="writeMessage('Mouseout circle')" @mousedown="writeMessage('Mousedown circle')" @mouseup="writeMessage('Mouseup circle')" /> </v-layer> </v-stage> </template> <script setup> import { ref } from 'vue'; const stageRef = ref(null); const message = ref(''); const stageSize = { width: window.innerWidth, height: window.innerHeight }; const textConfig = { x: 10, y: 10, fontFamily: 'Calibri', fontSize: 24, text: message, fill: 'black' }; const triangleConfig = { x: 80, y: 120, sides: 3, radius: 80, fill: '#00D2FF', stroke: 'black', strokeWidth: 4 }; const circleConfig = { x: 230, y: 100, radius: 60, fill: 'red', stroke: 'black', strokeWidth: 4 }; const writeMessage = (text) => { message.value = text; }; const handleTriangleMouseMove = () => { const mousePos = stageRef.value.getNode().getPointerPosition(); writeMessage('x: ' + mousePos.x + ', y: ' + mousePos.y); }; </script> Open on CodeSandboxOpen Sandbox

================================================================================


Filters - KonvaJS Documentation
===============================

Source: https://konvajs.org/docs/filters/Blur.html

To apply filter to an Konva.Image, we have to cache it first with cache() function. Then apply filter with filters() function. To blur an image with Konva, we can use the Konva.Filters.Blur filter and set the blur amount with the blurRadius property. Instructions: Slide the control to adjust the blur radius. For all available filters go to Filters Documentation. VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; const width = window.innerWidth; const height = window.innerHeight; const stage = new Konva.Stage({ container: 'container', width: width, height: height, }); const layer = new Konva.Layer(); stage.add(layer); const imageObj = new Image(); imageObj.onload = () => { const image = new Konva.Image({ x: 50, y: 50, image: imageObj, draggable: true, }); layer.add(image); image.cache(); image.filters([Konva.Filters.Blur]); image.blurRadius(10); const slider = document.createElement('input'); slider.type = 'range'; slider.min = '0'; slider.max = '40'; slider.value = image.blurRadius(); slider.style.position = 'absolute'; slider.style.top = '20px'; slider.style.left = '20px'; slider.addEventListener('input', (e) => { const value = parseInt(e.target.value); image.blurRadius(value); }); document.body.appendChild(slider); }; imageObj.src = 'https://konvajs.org/assets/lion.png'; imageObj.crossOrigin = 'anonymous'; Open on CodeSandboxOpen Sandboximport { Stage, Layer, Image } from 'react-konva'; import { useState, useEffect, useRef } from 'react'; import useImage from 'use-image'; const App = () => { const [blurRadius, setBlurRadius] = useState(10); const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous'); const imageRef = useRef(null); useEffect(() => { if (image && imageRef.current) { imageRef.current.cache(); } }, [image]); return ( <> <Stage width={window.innerWidth} height={window.innerHeight}> <Layer> <Image ref={imageRef} x={50} y={50} image={image} draggable filters={[Konva.Filters.Blur]} blurRadius={blurRadius} /> </Layer> </Stage> <input type="range" min="0" max="40" value={blurRadius} onChange={(e) => setBlurRadius(parseInt(e.target.value))} style={{ position: 'absolute', top: '20px', left: '20px' }} /> </> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <div> <v-stage :config="stageSize"> <v-layer> <v-image ref="imageNode" :config="{ x: 50, y: 50, image: image, draggable: true, filters: [Konva.Filters.Blur], blurRadius: blurRadius, }" /> </v-layer> </v-stage> <input type="range" min="0" max="40" :value="blurRadius" @input="handleSlider" style="position: absolute; top: 20px; left: 20px" /> </div> </template> <script setup> import { ref, watch, nextTick } from 'vue'; import { useImage } from 'vue-konva'; import Konva from 'konva'; const stageSize = { width: window.innerWidth, height: window.innerHeight, }; const blurRadius = ref(10); const imageNode = ref(null); const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous'); watch(image, async (newImage) => { if (newImage) { await nextTick(); imageNode.value.getNode().cache(); } }); const handleSlider = (e) => { blurRadius.value = parseInt(e.target.value); }; </script> Open on CodeSandboxOpen Sandbox

================================================================================


Groups and Layers - KonvaJS Documentation
=========================================

Source: https://konvajs.org/docs/groups_and_layers/Change_Containers.html

To move a shape from one container into another with Konva, we can use the moveTo() method which requires a container as a parameter. A container can be another stage, a layer, or a group. You can also move groups into other groups and layers, or shapes from groups directly into other layers. Instructions: Drag and drop the groups and observe that the red rectangle is bound to either the yellow group or the blue group. Use the buttons on the left to move the box from one group into another. VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; const width = window.innerWidth; const height = window.innerHeight; const stage = new Konva.Stage({ container: 'container', width: width, height: height, }); const layer = new Konva.Layer(); // yellow group const group1 = new Konva.Group({ x: 50, y: 50, draggable: true, }); const yellow = new Konva.Rect({ width: 100, height: 100, fill: 'yellow', stroke: 'black', strokeWidth: 4, }); group1.add(yellow); // blue group const group2 = new Konva.Group({ x: 200, y: 50, draggable: true, }); const blue = new Konva.Rect({ width: 100, height: 100, fill: 'blue', stroke: 'black', strokeWidth: 4, }); group2.add(blue); // red box const redBox = new Konva.Rect({ x: 10, y: 10, width: 30, height: 30, fill: 'red', }); group1.add(redBox); layer.add(group1); layer.add(group2); stage.add(layer); // create buttons const moveToGroup1Btn = document.createElement('button'); moveToGroup1Btn.textContent = 'Move to yellow group'; moveToGroup1Btn.addEventListener('click', () => { redBox.moveTo(group1); }); const moveToGroup2Btn = document.createElement('button'); moveToGroup2Btn.textContent = 'Move to blue group'; moveToGroup2Btn.addEventListener('click', () => { redBox.moveTo(group2); }); document.body.appendChild(moveToGroup1Btn); document.body.appendChild(moveToGroup2Btn); Open on CodeSandboxOpen Sandboximport { Stage, Layer, Rect, Group } from 'react-konva'; import { useState } from 'react'; const App = () => { const [redBoxGroup, setRedBoxGroup] = useState('yellow'); return ( <> <button onClick={() => setRedBoxGroup('yellow')}> Move to yellow group </button> <button onClick={() => setRedBoxGroup('blue')}> Move to blue group </button> <Stage width={window.innerWidth} height={window.innerHeight}> <Layer> <Group x={50} y={50} draggable> <Rect width={100} height={100} fill="yellow" stroke="black" strokeWidth={4} /> {redBoxGroup === 'yellow' && ( <Rect x={10} y={10} width={30} height={30} fill="red" /> )} </Group> <Group x={200} y={50} draggable> <Rect width={100} height={100} fill="blue" stroke="black" strokeWidth={4} /> {redBoxGroup === 'blue' && ( <Rect x={10} y={10} width={30} height={30} fill="red" /> )} </Group> </Layer> </Stage> </> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <div> <button @click="moveToYellow">Move to yellow group</button> <button @click="moveToBlue">Move to blue group</button> <v-stage :config="stageSize"> <v-layer> <v-group :config="yellowGroupConfig"> <v-rect :config="yellowBoxConfig" /> <v-rect v-if="redBoxGroup === 'yellow'" :config="redBoxConfig" /> </v-group> <v-group :config="blueGroupConfig"> <v-rect :config="blueBoxConfig" /> <v-rect v-if="redBoxGroup === 'blue'" :config="redBoxConfig" /> </v-group> </v-layer> </v-stage> </div> </template> <script setup> import { ref } from 'vue'; const stageSize = { width: window.innerWidth, height: window.innerHeight }; const redBoxGroup = ref('yellow'); const yellowGroupConfig = { x: 50, y: 50, draggable: true }; const blueGroupConfig = { x: 200, y: 50, draggable: true }; const yellowBoxConfig = { width: 100, height: 100, fill: 'yellow', stroke: 'black', strokeWidth: 4 }; const blueBoxConfig = { width: 100, height: 100, fill: 'blue', stroke: 'black', strokeWidth: 4 }; const redBoxConfig = { x: 10, y: 10, width: 30, height: 30, fill: 'red' }; const moveToYellow = () => { redBoxGroup.value = 'yellow'; }; const moveToBlue = () => { redBoxGroup.value = 'blue'; }; </script> Open on CodeSandboxOpen Sandbox

================================================================================


Intro - KonvaJS Documentation
=============================

Source: https://konvajs.org/docs/index.html

What's Konva?​ Konva is an HTML5 Canvas JavaScript framework that extends the 2d context by enabling canvas interactivity for desktop and mobile applications. Konva enables high performance animations, transitions, node nesting, layering, filtering, caching, event handling for desktop and mobile applications, and much more. You can draw things onto the stage, add event listeners to them, move them, scale them, and rotate them independently from other shapes to support high performance animations, even if your application uses thousands of shapes. This project began as a GitHub fork of KineticJS. Install Konva​ If you are using package managers: npm install konva Or just use script tag: <script src="https://unpkg.com/konva@9/konva.min.js"></script> Or download from CDN: Full version konva.js Min version konva.min.js

================================================================================


Overview - KonvaJS Documentation
================================

Source: https://konvajs.org/docs/overview.html

On this pageWhat's Konva?​ Konva is an HTML5 Canvas JavaScript framework that extends the 2d context by enabling canvas interactivity for desktop and mobile applications. Konva enables high performance animations, transitions, node nesting, layering, filtering, caching, event handling for desktop and mobile applications, and much more. How does it work?​ Every thing starts from Konva.Stage that contains several user's layers (Konva.Layer). Each layer has two <canvas> renderers: a scene renderer and a hit graph renderer. The scene renderer is what you can see, and the hit graph renderer is a special hidden canvas that's used for high performance event detection. Each layer can contain shapes, groups of shapes, or groups of other groups. The stage, layers, groups, and shapes are virtual nodes, similar to DOM nodes in an HTML page. Here's an example Node hierarchy: Stage | +------+------+ | | Layer Layer | | +-----+-----+ Shape | | Group Group | | + +---+---+ | | | Shape Group Shape | + | Shape All nodes can be styled and transformed. Although Konva has prebuilt shapes available, such as rectangles, circles, images, sprites, text, lines, polygons, regular polygons, paths, stars, etc., you can also create custom shapes by instantiating the Shape class and creating a draw function. Once you have a stage set up with layers and shapes, you can bind event listeners, transform nodes, run animations, apply filters, and much more. Minimal code example: // first we need to create a stagevar stage = new Konva.Stage({ container: 'container', // id of container <div> width: 500, height: 500,});// then create layervar layer = new Konva.Layer();// create our shapevar circle = new Konva.Circle({ x: stage.width() / 2, y: stage.height() / 2, radius: 70, fill: 'red', stroke: 'black', strokeWidth: 4,});// add the shape to the layerlayer.add(circle);// add the layer to the stagestage.add(layer); Result: Basic shapes​ Konva.js supports shapes: Rect, Circle, Ellipse, Line, Polygon, Spline, Blob, Image, Text, TextPath, Star, Label, SVG Path, RegularPolygon. Also you can create custom shape: var triangle = new Konva.Shape({ sceneFunc: function (context) { context.beginPath(); context.moveTo(20, 50); context.lineTo(220, 80); context.quadraticCurveTo(150, 100, 260, 170); context.closePath(); // special Konva.js method context.fillStrokeShape(this); }, fill: '#00D2FF', stroke: 'black', strokeWidth: 4,}); Styles​ Each shape supports the following style properties: Fill. Solid color, gradients or images Stroke (color, width) Shadow (color, offset, opacity, blur) Opacity var pentagon = new Konva.RegularPolygon({ x: stage.width() / 2, y: stage.height() / 2, sides: 5, radius: 70, fill: 'red', stroke: 'black', strokeWidth: 4, shadowOffsetX: 20, shadowOffsetY: 25, shadowBlur: 40, opacity: 0.5,}); Events​ With Konva you can easily listen to user input events (click, dblclick, mouseover, tap, dbltap, touchstart etc), attributes change events (scaleXChange, fillChange) and drag&drop events (dragstart, dragmove, dragend). circle.on('mouseout touchend', function () { console.log('user input');});circle.on('xChange', function () { console.log('position change');});circle.on('dragend', function () { console.log('drag stopped');}); See working example. DRAG AND DROP​ Konva has builtin drag support. For the current moment there is no drop events (drop, dragenter, dragleave, dragover) but it is very easy to implement them via framework. To enable drag&drop just set property draggable = true. shape.draggable('true'); Then you can subscribe to drag&drop events and setup moving limits. Filters​ Konva has several filters: blur, invert, noise etc. For all available filters see Filters API. Example: Animation​ You can create animations in two ways: via Konva.Animation Demo: var anim = new Konva.Animation(function (frame) { var time = frame.time, timeDiff = frame.timeDiff, frameRate = frame.frameRate; // update stuff}, layer);anim.start(); via Konva.Tween Demo: var tween = new Konva.Tween({ node: rect, duration: 1, x: 140, rotation: Math.PI * 2, opacity: 1, strokeWidth: 6,});tween.play();// or new shorter method:circle.to({ duration: 1, fill: 'green',}); Selectors​ It is very useful to use searching in elements when you are building large application. Konva helps you to find an element with selectors. You can use find() method (returns collection) or findOne() method (return first element of collection). var circle = new Konva.Circle({ radius: 10, fill: 'red', id: 'face', name: 'red circle',});layer.add(circle);// then try to search// find by typelayer.find('Circle'); // returns array of all circles// find by idlayer.findOne('#face');// find by name (like css class)layer.find('.red'); Serialisation and Deserialization​ All created objects you can save as JSON. You may save it to server or local storage. var json = stage.toJSON(); Also you can restore objects from JSON: var json = '{"attrs":{"width":578,"height":200},"className":"Stage","children":[{"attrs":{},"className":"Layer","children":[{"attrs":{"x":100,"y":100,"sides":6,"radius":70,"fill":"red","stroke":"black","strokeWidth":4},"className":"RegularPolygon"}]}]}';var stage = Konva.Node.create(json, 'container'); Performance​ Konva has a lot of tools to improve speed of your app. Most important methods: Caching allows you to draw an element into buffer canvas. Then draw element from the canvas. It may improve performance a lot for complex nodes such as text or shapes with shadow and strokes. shape.cache(); Demo Layering. As framework supports several <canvas> elements you can put objects at your discretion. For example your application consists from complex background and several moving shapes. You can use one layer for background and another one for shapes. While updating shapes you don't need to update background canvas. Demo You can find all available performance tips here: https://konvajs.org/docs/performance/All_Performance_Tips.html

================================================================================


Performance - KonvaJS Documentation
===================================

Source: https://konvajs.org/docs/performance/All_Performance_Tips.html

Don't want to spend your time with performance issues? Request a performance review. Why this is important​ The HTML5 canvas is efficient at what it does and internally Konva has many features that aim to provide great performance. However, when your project starts to grow in complexity, or when you just have a lot of shapes on the stage, there must inevitably be some negative performance impact. Optimization targets​ The optimizations here focus on two general rules: Compute as little as possible: all computation takes time to complete. Each individual computation may run in a tiny fraction of a second, but the thousands or millions of computations caused by your code, Konva, JavaScript, and the layers below that, will add up to something more observable by the human eye if that super-slick animation or effect is, in fact, jerky. Draw as little as possible: this is important because all drawing has a performance cost. There are two categories of cost - firstly the computation of the drawing which we covered in the point above, and then the movement of the drawing from memory to the screen. Depending on the case, there may also be intermediate off-screen compositing or per-pixel processing. The rule is therefore do as little drawing as possible. The Stage​ Optimise stage size - following the rule of 'draw as little as possible', try to avoid creating a large stage because moving all those bytes from memory to screen is going to have a negative impact. There are some tips here that offer alternative approaches to the mega-stage problem! Set a viewport on mobile - Scaling images is a significant performance hit, so for mobile applications set viewport: <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> which will avoid unnecessary scaling of your Konva output. Use Konva.pixelRatio = 1 on retina devices - Konva automatically handles pixel ratio adjustments in order to render crisp drawings on all devices. But, just in case you have bad performance on retina devices, set Konva.pixelRatio = 1 to reduce the scaling work Konva has to do. This setting might affect the output in some cases, so make sure that quality of the result is ok for you. Layers​ Layer Management - under the hood, each Konva layer is a separate HTML5 canvas element which gives some useful capabilities, including the ability to refresh only a layer that changed and so avoid the performance cost of refreshing the entire stage. But with great power great responsibility comes, and each layer has an incremental performance overhead so we should keep the number of layers to a minimum. Use layer.listening(false) - Konva gives us mouse and touch event listeners on all the shapes we draw. But there is a performance cost for each one, and for a layer with many shapes Konva has to expend many cycles checking which listeners might be triggered. If you have a layer on which none of the shapes need to react to events, take this burden away by setting layer.listening(false). See Demo. There is a similar point in the shapes section. Optimise dragging costs - while you drag a shape across a layer that layer must be redrawn per cycle of the move event listener. To avoid this performance cost, move the shape to a dedicated layer while dragging, then move it back to original layer at drag end. See Demo Shapes​ Shape Caching - internally Konva makes an image of your shape and uses that when the shape has to be drawn. Drawing images avoids the overhead of composing the shape from its drawing instructions, and can increase performance impressively for complex shapes and groups. Keep the shapes tidy - each shape in your stage has a cost just to exist. To optimise performance, hide or remove from the layer any objects that become invisible / opacity = 0, or objects that go out of view. Use shape.listening(false) - as with layers (see point 7 above), Konva looks out for when events should be triggered for shapes, which has a performance cost. Telling a shape to stop listening for events reduces this cost, as explained at Listening false. Switch off perfect drawing - In some cases the result of drawing with the HTML5 canvas is not what you might have expected - see the demo for an example Disable Perfect Drawing. Konva does extra work via its perfect drawing feature to put that right, but this comes with a performance cost. By setting shape.perfectDrawEnabled(false) this cost can be avoided, with no reduction in output quality, when a shape has fill, stroke and opacity. Optimize Stroke Drawing - To achieve drawing results that look as expected, Konva makes an extra internal drawing when a shape has both stroke and shadow. Avoid this performance burden by switching off the shadow that Konva adds for the stroke. Animations​ Optimize Animation - Avoiding unnecessary redraw costs for animation steps that fall between visual changes. Memory​ Avoid Memory Leaks - Konva looks after a lot of cases where you might make memory leaks, but bringing shapes and tweens into the world and managing their exit is an area where you can help. Below is a demo showing some of these performance tips in action: VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; // Create stage with good performance settings const stage = new Konva.Stage({ container: 'container', width: window.innerWidth, height: window.innerHeight, }); // Create layers with performance optimizations const backgroundLayer = new Konva.Layer({ listening: false }); const mainLayer = new Konva.Layer(); const dragLayer = new Konva.Layer(); stage.add(backgroundLayer); stage.add(mainLayer); stage.add(dragLayer); // Create a shape with caching const star = new Konva.Star({ x: 200, y: 200, numPoints: 6, innerRadius: 40, outerRadius: 70, fill: 'yellow', stroke: 'black', strokeWidth: 4, draggable: true, perfectDrawEnabled: false, // performance optimization }); // Cache the shape for better performance star.cache(); // Optimize dragging performance star.on('dragstart', () => { star.moveTo(dragLayer); }); star.on('dragend', () => { star.moveTo(mainLayer); }); // Create background with listening disabled const rect = new Konva.Rect({ x: 0, y: 0, width: stage.width(), height: stage.height(), fill: 'lightgray', listening: false, }); backgroundLayer.add(rect); mainLayer.add(star); Open on CodeSandboxOpen Sandboximport { Stage, Layer, Star, Rect } from 'react-konva'; import { useState, useRef, useEffect } from 'react'; const App = () => { const [starLayer, setStarLayer] = useState('main'); const starRef = useRef(null); useEffect(() => { // Cache the shape for better performance if (starRef.current) { starRef.current.cache(); } }, []); const handleDragStart = () => { setStarLayer('drag'); }; const handleDragEnd = () => { setStarLayer('main'); }; return ( <Stage width={window.innerWidth} height={window.innerHeight}> <Layer listening={false}> <Rect x={0} y={0} width={window.innerWidth} height={window.innerHeight} fill="lightgray" /> </Layer> <Layer> {starLayer === 'main' && ( <Star ref={starRef} x={200} y={200} numPoints={6} innerRadius={40} outerRadius={70} fill="yellow" stroke="black" strokeWidth={4} draggable perfectDrawEnabled={false} onDragStart={handleDragStart} onDragEnd={handleDragEnd} /> )} </Layer> <Layer> {starLayer === 'drag' && ( <Star ref={starRef} x={200} y={200} numPoints={6} innerRadius={40} outerRadius={70} fill="yellow" stroke="black" strokeWidth={4} draggable perfectDrawEnabled={false} onDragStart={handleDragStart} onDragEnd={handleDragEnd} /> )} </Layer> </Stage> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <v-stage :config="stageSize"> <v-layer :config="{ listening: false }"> <v-rect :config="rectConfig" /> </v-layer> <v-layer> <v-star v-if="starLayer === 'main'" ref="starRef" :config="starConfig" @dragstart="handleDragStart" @dragend="handleDragEnd" /> </v-layer> <v-layer> <v-star v-if="starLayer === 'drag'" ref="starRef" :config="starConfig" @dragstart="handleDragStart" @dragend="handleDragEnd" /> </v-layer> </v-stage> </template> <script setup> import { ref, onMounted } from 'vue'; const stageSize = { width: window.innerWidth, height: window.innerHeight }; const rectConfig = { x: 0, y: 0, width: window.innerWidth, height: window.innerHeight, fill: 'lightgray' }; const starConfig = { x: 200, y: 200, numPoints: 6, innerRadius: 40, outerRadius: 70, fill: 'yellow', stroke: 'black', strokeWidth: 4, draggable: true, perfectDrawEnabled: false }; const starLayer = ref('main'); const starRef = ref(null); onMounted(() => { // Cache the shape for better performance if (starRef.value) { starRef.value.getNode().cache(); } }); const handleDragStart = () => { starLayer.value = 'drag'; }; const handleDragEnd = () => { starLayer.value = 'main'; }; </script> Open on CodeSandboxOpen Sandbox

================================================================================


Posts - KonvaJS Documentation
=============================

Source: https://konvajs.org/docs/posts/Position_vs_Offset.html

There are several properties in Konva that looks similar and may lead some confusion but have a different effect and purpose. In the post I will explain the difference between position (x and y coordinates) and offset (offsetX and offsetY). So x and y properties define position of Node on canvas. If you set draggable = true property and start dragging, Konva will change x and y properties of the node. That logic will be applied for all nodes (even Konva.Line). Position of a rectangle shape defines its top-left point. Position of circle defines its center. index.htmlindex.jsimport Konva from 'konva'; const stage = new Konva.Stage({ container: 'container', width: window.innerWidth, height: window.innerHeight, }); var layer = new Konva.Layer(); var rect = new Konva.Rect({ x: 20, y: 20, width: 100, height: 100, fill: 'yellow', stroke: 'black', strokeWidth: 4, draggable: true, }); // add the shape to the layer layer.add(rect); var circle = new Konva.Circle({ x: 150, y: 120, radius: 50, fill: 'red', stroke: 'black', strokeWidth: 4, draggable: true, }); // add the shape to the layer layer.add(circle); var text = new Konva.Text(); layer.add(text); // add the layer to the stage stage.add(layer); function updateText(e) { text.text('Position: x = ' + e.target.x() + ' y = ' + e.target.y()); } rect.on('dragmove', updateText); circle.on('dragmove', updateText); Open on CodeSandboxOpen Sandbox Why do we need an offset property?​ When you are changing the offset property it may looks like you are changing position of the node. But actually not. You are changing ORIGIN of the shape. What is it origin? You may think of it as "point from where we start drawing of a shape" or "center of the shape" or "the point around which we rotating a shape". Just a small note, long time ago offset property was called "center" in Konva codebase (when it was KineticJS project). But later it was refactored to "offset". Take a look into this demo. All rectangles here have the same y position, but a different offset property. index.htmlindex.jsimport Konva from 'konva'; const stage = new Konva.Stage({ container: 'container', width: window.innerWidth, height: window.innerHeight, }); const layer = new Konva.Layer(); stage.add(layer); const centerY = stage.height() / 2; // rectangle with no offset const rect1 = new Konva.Rect({ x: 50, y: centerY, width: 100, height: 100, fill: 'red', stroke: 'black', strokeWidth: 2, }); layer.add(rect1); // rectangle with offset at center const rect2 = new Konva.Rect({ x: 200, y: centerY, width: 100, height: 100, fill: 'green', stroke: 'black', strokeWidth: 2, offsetX: 50, offsetY: 50, rotation: 45 }); layer.add(rect2); // rectangle with custom offset const rect3 = new Konva.Rect({ x: 350, y: centerY, width: 100, height: 100, fill: 'blue', stroke: 'black', strokeWidth: 2, offsetX: 100, offsetY: 0, rotation: 45 }); layer.add(rect3); Open on CodeSandboxOpen Sandbox And you should understand that Konva has two main methods to define origin of the shape. So "circle-like" shapes have origin at actual center of the shape (Circle, Ellipse, Wedge, Star, Ring ,etc). When you set {x, y} of a circle you are defining "where will be the center of the circle". And "rectangle-like" shapes has origin at TOP LEFT (Rectangle, Sprite, Text, Image, etc) When you set {x, y} of a rectangle you are defining "where will be the top-left point of the rect". So a shape will be rotated around its origin point (around its "center"). So if you set rotation 45 deg of a star it will be rotated around its actual center. But if you set rotation 45 deg of rectangle, it will be rotated around top-left. But in some cases it is not convenient. Sometimes you may want to rotate the shape around its center. In this case you can set offset property. By using it we will tell konva: "Hey, use this point as the new origin of the shape". How to set rotation point of a shape?​ Now let's think you are placed a 100x100 rectangle in x = 0, y = 0, and now you want to rotate it around its center. If you are not using offset you have to recalculate position of it't top left edge (recall you trigonometry lessons from the school). You can do this by using something like this: const rotatePoint = ({ x, y }, rad) => { const rcos = Math.cos(rad); const rsin = Math.sin(rad); return { x: x * rcos - y * rsin, y: y * rcos + x * rsin };};// will work for shapes with top-left origin, like rectanglefunction rotateAroundCenter(node, rotation) { //current rotation origin (0, 0) relative to desired origin - center (node.width()/2, node.height()/2) const topLeft = { x: -node.width() / 2, y: -node.height() / 2 }; const current = rotatePoint(topLeft, Konva.getAngle(node.rotation())); const rotated = rotatePoint(topLeft, Konva.getAngle(rotation)); const dx = rotated.x - current.x, dy = rotated.y - current.y; node.rotation(rotation); node.x(node.x() + dx); node.y(node.y() + dy);}// then use itrotateAroundCenter(rect, 180); Or you can set offsetX = width / 2 and offsetY = height / 2. But the rectangle will be moved on the canvas (since you change its origin). So you will need to adjust the position. Still have a question? Ask in comments.

================================================================================


React - KonvaJS Documentation
=============================

Source: https://konvajs.org/docs/react/index.html

react-konva is a JavaScript library for drawing complex canvas graphics using React. It provides declarative and reactive bindings to the Konva Framework. Github Repo It is an attempt to make React work with the HTML5 canvas library. The goal is to have a similar declarative markup as normal React and also a similar data-flow model. Currently, react-konva is not supported in the React Native environment. Currently you can use all Konva nodes and shapes as React components and all Konva events are supported on them in the same way. Note: you can find a lot of demos and examples for using Konva at https://konvajs.org/. Really, just go there and take a look at what Konva can do for you. You will be able to do the same with react-konva, too. Konva for react-konva is like DOM for React. Installation​ npm install react-konva konva --save Here's a basic example showing how to create a simple canvas with some shapes: import React from 'react'; import { Stage, Layer, Rect, Circle, Text } from 'react-konva'; const App = () => { return ( <Stage width={window.innerWidth} height={window.innerHeight}> <Layer> <Text text="Try to drag shapes" fontSize={15} /> <Rect x={20} y={50} width={100} height={100} fill="red" shadowBlur={10} draggable /> <Circle x={200} y={100} radius={50} fill="green" draggable /> </Layer> </Stage> ); }; export default App; Open on CodeSandboxOpen Sandbox

================================================================================


Select and Transform - KonvaJS Documentation
============================================

Source: https://konvajs.org/docs/select_and_transform/Basic_demo.html

Transformer is a special kind of Konva.Group. It allows you easily resize and rotate any node or set of nodes. To enable it you need to: Create new instance with new Konva.Transformer() Add it to layer attach to node with transformer.nodes([shape]); Note: Transforming tool is not changing width and height properties of nodes when you resize them. Instead it changes scaleX and scaleY properties. Instructions: Try to resize and rotate shapes. Click on empty area to remove selection. Use SHIFT or CTRL to add/remove shapes into/from selection. Try to select area on a canvas. VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; const width = window.innerWidth; const height = window.innerHeight; const stage = new Konva.Stage({ container: 'container', width: width, height: height, }); const layer = new Konva.Layer(); stage.add(layer); // create rectangle const rect1 = new Konva.Rect({ x: 60, y: 60, width: 100, height: 90, fill: 'red', name: 'rect', draggable: true, }); layer.add(rect1); const rect2 = new Konva.Rect({ x: 250, y: 100, width: 150, height: 90, fill: 'green', name: 'rect', draggable: true, }); layer.add(rect2); // create transformer const tr = new Konva.Transformer(); layer.add(tr); // add a new feature, lets add ability to draw selection rectangle let selectionRectangle = new Konva.Rect({ fill: 'rgba(0,0,255,0.5)', visible: false, }); layer.add(selectionRectangle); let x1, y1, x2, y2; stage.on('mousedown touchstart', (e) => { // do nothing if we mousedown on any shape if (e.target !== stage) { return; } x1 = stage.getPointerPosition().x; y1 = stage.getPointerPosition().y; x2 = stage.getPointerPosition().x; y2 = stage.getPointerPosition().y; selectionRectangle.setAttrs({ x: x1, y: y1, width: 0, height: 0, visible: true, }); }); stage.on('mousemove touchmove', () => { // do nothing if we didn't start selection if (!selectionRectangle.visible()) { return; } x2 = stage.getPointerPosition().x; y2 = stage.getPointerPosition().y; selectionRectangle.setAttrs({ x: Math.min(x1, x2), y: Math.min(y1, y2), width: Math.abs(x2 - x1), height: Math.abs(y2 - y1), }); }); stage.on('mouseup touchend', () => { // do nothing if we didn't start selection if (!selectionRectangle.visible()) { return; } // update visibility in timeout, so we can check it in click event setTimeout(() => { selectionRectangle.visible(false); }); var shapes = stage.find('.rect'); var box = selectionRectangle.getClientRect(); var selected = shapes.filter((shape) => Konva.Util.haveIntersection(box, shape.getClientRect()) ); tr.nodes(selected); }); // clicks should select/deselect shapes stage.on('click tap', function (e) { // if we are selecting with rect, do nothing if (selectionRectangle.visible() && selectionRectangle.width() > 0 && selectionRectangle.height() > 0) { return; } // if click on empty area - remove all selections if (e.target === stage) { tr.nodes([]); return; } // do nothing if clicked NOT on our rectangles if (!e.target.hasName('rect')) { return; } // do we pressed shift or ctrl? const metaPressed = e.evt.shiftKey || e.evt.ctrlKey || e.evt.metaKey; const isSelected = tr.nodes().indexOf(e.target) >= 0; if (!metaPressed && !isSelected) { // if no key pressed and the node is not selected // select just one tr.nodes([e.target]); } else if (metaPressed && isSelected) { // if we pressed keys and node was selected // we need to remove it from selection: const nodes = tr.nodes().slice(); // use slice to have new copy of array // remove node from array nodes.splice(nodes.indexOf(e.target), 1); tr.nodes(nodes); } else if (metaPressed && !isSelected) { // add the node into selection const nodes = tr.nodes().concat([e.target]); tr.nodes(nodes); } }); Open on CodeSandboxOpen Sandboximport { Stage, Layer, Rect, Transformer } from 'react-konva'; import { useState, useEffect, useRef } from 'react'; const initialRectangles = [ { x: 60, y: 60, width: 100, height: 90, fill: 'red', id: 'rect1', name: 'rect', rotation: 0, }, { x: 250, y: 100, width: 150, height: 90, fill: 'green', id: 'rect2', name: 'rect', rotation: 0, }, ]; // Helper functions for calculating bounding boxes of rotated rectangles const degToRad = (angle) => (angle / 180) * Math.PI; const getCorner = (pivotX, pivotY, diffX, diffY, angle) => { const distance = Math.sqrt(diffX * diffX + diffY * diffY); angle += Math.atan2(diffY, diffX); const x = pivotX + distance * Math.cos(angle); const y = pivotY + distance * Math.sin(angle); return { x, y }; }; const getClientRect = (element) => { const { x, y, width, height, rotation = 0 } = element; const rad = degToRad(rotation); const p1 = getCorner(x, y, 0, 0, rad); const p2 = getCorner(x, y, width, 0, rad); const p3 = getCorner(x, y, width, height, rad); const p4 = getCorner(x, y, 0, height, rad); const minX = Math.min(p1.x, p2.x, p3.x, p4.x); const minY = Math.min(p1.y, p2.y, p3.y, p4.y); const maxX = Math.max(p1.x, p2.x, p3.x, p4.x); const maxY = Math.max(p1.y, p2.y, p3.y, p4.y); return { x: minX, y: minY, width: maxX - minX, height: maxY - minY, }; }; const App = () => { const [rectangles, setRectangles] = useState(initialRectangles); const [selectedIds, setSelectedIds] = useState([]); const [selectionRectangle, setSelectionRectangle] = useState({ visible: false, x1: 0, y1: 0, x2: 0, y2: 0, }); const isSelecting = useRef(false); const transformerRef = useRef(); const rectRefs = useRef(new Map()); // Update transformer when selection changes useEffect(() => { if (selectedIds.length && transformerRef.current) { // Get the nodes from the refs Map const nodes = selectedIds .map(id => rectRefs.current.get(id)) .filter(node => node); transformerRef.current.nodes(nodes); } else if (transformerRef.current) { // Clear selection transformerRef.current.nodes([]); } }, [selectedIds]); // Click handler for stage const handleStageClick = (e) => { // If we are selecting with rect, do nothing if (selectionRectangle.visible) { return; } // If click on empty area - remove all selections if (e.target === e.target.getStage()) { setSelectedIds([]); return; } // Do nothing if clicked NOT on our rectangles if (!e.target.hasName('rect')) { return; } const clickedId = e.target.id(); // Do we pressed shift or ctrl? const metaPressed = e.evt.shiftKey || e.evt.ctrlKey || e.evt.metaKey; const isSelected = selectedIds.includes(clickedId); if (!metaPressed && !isSelected) { // If no key pressed and the node is not selected // select just one setSelectedIds([clickedId]); } else if (metaPressed && isSelected) { // If we pressed keys and node was selected // we need to remove it from selection setSelectedIds(selectedIds.filter(id => id !== clickedId)); } else if (metaPressed && !isSelected) { // Add the node into selection setSelectedIds([...selectedIds, clickedId]); } }; const handleMouseDown = (e) => { // Do nothing if we mousedown on any shape if (e.target !== e.target.getStage()) { return; } // Start selection rectangle isSelecting.current = true; const pos = e.target.getStage().getPointerPosition(); setSelectionRectangle({ visible: true, x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y, }); }; const handleMouseMove = (e) => { // Do nothing if we didn't start selection if (!isSelecting.current) { return; } const pos = e.target.getStage().getPointerPosition(); setSelectionRectangle({ ...selectionRectangle, x2: pos.x, y2: pos.y, }); }; const handleMouseUp = () => { // Do nothing if we didn't start selection if (!isSelecting.current) { return; } isSelecting.current = false; // Update visibility in timeout, so we can check it in click event setTimeout(() => { setSelectionRectangle({ ...selectionRectangle, visible: false, }); }); const selBox = { x: Math.min(selectionRectangle.x1, selectionRectangle.x2), y: Math.min(selectionRectangle.y1, selectionRectangle.y2), width: Math.abs(selectionRectangle.x2 - selectionRectangle.x1), height: Math.abs(selectionRectangle.y2 - selectionRectangle.y1), }; const selected = rectangles.filter(rect => { // Check if rectangle intersects with selection box return Konva.Util.haveIntersection(selBox, getClientRect(rect)); }); setSelectedIds(selected.map(rect => rect.id)); }; const handleDragEnd = (e) => { const id = e.target.id(); setRectangles(prevRects => { const newRects = [...prevRects]; const index = newRects.findIndex(r => r.id === id); if (index !== -1) { newRects[index] = { ...newRects[index], x: e.target.x(), y: e.target.y() }; } return newRects; }); }; const handleTransformEnd = (e) => { // Find which rectangle(s) were transformed const id = e.target.id(); const node = e.target; setRectangles(prevRects => { const newRects = [...prevRects]; // Update each transformed node const index = newRects.findIndex(r => r.id === id); if (index !== -1) { const scaleX = node.scaleX(); const scaleY = node.scaleY(); // Reset scale node.scaleX(1); node.scaleY(1); // Update the state with new values newRects[index] = { ...newRects[index], x: node.x(), y: node.y(), width: Math.max(5, node.width() * scaleX), height: Math.max(node.height() * scaleY), rotation: node.rotation(), }; } return newRects; }); }; return ( <Stage width={window.innerWidth} height={window.innerHeight} onMouseDown={handleMouseDown} onMousemove={handleMouseMove} onMouseup={handleMouseUp} onClick={handleStageClick} > <Layer> {/* Render rectangles directly */} {rectangles.map(rect => ( <Rect key={rect.id} id={rect.id} x={rect.x} y={rect.y} width={rect.width} height={rect.height} fill={rect.fill} name={rect.name} rotation={rect.rotation} draggable ref={node => { if (node) { rectRefs.current.set(rect.id, node); } }} onDragEnd={handleDragEnd} onTransformEnd={handleTransformEnd} /> ))} {/* Single transformer for all selected shapes */} <Transformer ref={transformerRef} boundBoxFunc={(oldBox, newBox) => { // Limit resize if (newBox.width < 5 || newBox.height < 5) { return oldBox; } return newBox; }} /> {/* Selection rectangle */} {selectionRectangle.visible && ( <Rect x={Math.min(selectionRectangle.x1, selectionRectangle.x2)} y={Math.min(selectionRectangle.y1, selectionRectangle.y2)} width={Math.abs(selectionRectangle.x2 - selectionRectangle.x1)} height={Math.abs(selectionRectangle.y2 - selectionRectangle.y1)} fill="rgba(0,0,255,0.5)" /> )} </Layer> </Stage> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <v-stage :config="stageSize" @mousedown="handleMouseDown" @mousemove="handleMouseMove" @mouseup="handleMouseUp" @click="handleStageClick" ref="stageRef" > <v-layer ref="layerRef"> <v-rect v-for="(rect, i) in rectangles" :key="i" :config="{ ...rect, name: 'rect', // Important to match vanilla version's logic draggable: true }" @dragend="(e) => handleDragEnd(e, i)" @transformend="(e) => handleTransformEnd(e, i)" ref="rectRefs" /> <v-transformer ref="transformerRef" :config="{ boundBoxFunc: (oldBox, newBox) => { // limit resize if (newBox.width < 5 || newBox.height < 5) { return oldBox; } return newBox; }, }" /> <v-rect v-if="selectionRectangle.visible" :config="{ x: Math.min(selectionRectangle.x1, selectionRectangle.x2), y: Math.min(selectionRectangle.y1, selectionRectangle.y2), width: Math.abs(selectionRectangle.x2 - selectionRectangle.x1), height: Math.abs(selectionRectangle.y2 - selectionRectangle.y1), fill: 'rgba(0,0,255,0.5)' }" /> </v-layer> </v-stage> </template> <script setup> import { ref, watch, reactive, onMounted } from 'vue'; const stageSize = { width: window.innerWidth, height: window.innerHeight, }; const rectangles = ref([ { x: 60, y: 60, width: 100, height: 90, fill: 'red', id: 'rect1', rotation: 0, }, { x: 250, y: 100, width: 150, height: 90, fill: 'green', id: 'rect2', rotation: 0, }, ]); const selectedIds = ref([]); const rectRefs = ref([]); const transformerRef = ref(null); const stageRef = ref(null); const layerRef = ref(null); const isSelecting = ref(false); const selectionRectangle = reactive({ visible: false, x1: 0, y1: 0, x2: 0, y2: 0 }); // Helper functions for calculating bounding boxes of rotated rectangles const degToRad = (angle) => (angle / 180) * Math.PI; const getCorner = (pivotX, pivotY, diffX, diffY, angle) => { const distance = Math.sqrt(diffX * diffX + diffY * diffY); angle += Math.atan2(diffY, diffX); const x = pivotX + distance * Math.cos(angle); const y = pivotY + distance * Math.sin(angle); return { x, y }; }; const getClientRect = (element) => { const { x, y, width, height, rotation = 0 } = element; const rad = degToRad(rotation); const p1 = getCorner(x, y, 0, 0, rad); const p2 = getCorner(x, y, width, 0, rad); const p3 = getCorner(x, y, width, height, rad); const p4 = getCorner(x, y, 0, height, rad); const minX = Math.min(p1.x, p2.x, p3.x, p4.x); const minY = Math.min(p1.y, p2.y, p3.y, p4.y); const maxX = Math.max(p1.x, p2.x, p3.x, p4.x); const maxY = Math.max(p1.y, p2.y, p3.y, p4.y); return { x: minX, y: minY, width: maxX - minX, height: maxY - minY, }; }; // Update transformer nodes when selection changes watch(selectedIds, () => { if (!transformerRef.value) return; const nodes = selectedIds.value.map(id => { return rectRefs.value.find(ref => ref.getNode().attrs.id === id)?.getNode(); }).filter(Boolean); transformerRef.value.getNode().nodes(nodes); }); const handleStageClick = (e) => { // if we are selecting with rect, do nothing if (selectionRectangle.visible) { return; } // if click on empty area - remove all selections if (e.target === e.target.getStage()) { selectedIds.value = []; return; } // do nothing if clicked NOT on our rectangles if (!e.target.hasName('rect')) { return; } const clickedId = e.target.attrs.id; // do we pressed shift or ctrl? const metaPressed = e.evt.shiftKey || e.evt.ctrlKey || e.evt.metaKey; const isSelected = selectedIds.value.includes(clickedId); if (!metaPressed && !isSelected) { // if no key pressed and the node is not selected // select just one selectedIds.value = [clickedId]; } else if (metaPressed && isSelected) { // if we pressed keys and node was selected // we need to remove it from selection: selectedIds.value = selectedIds.value.filter(id => id !== clickedId); } else if (metaPressed && !isSelected) { // add the node into selection selectedIds.value = [...selectedIds.value, clickedId]; } }; const handleMouseDown = (e) => { // do nothing if we mousedown on any shape if (e.target !== e.target.getStage()) { return; } // start selection rectangle isSelecting.value = true; const pos = e.target.getStage().getPointerPosition(); selectionRectangle.visible = true; selectionRectangle.x1 = pos.x; selectionRectangle.y1 = pos.y; selectionRectangle.x2 = pos.x; selectionRectangle.y2 = pos.y; }; const handleMouseMove = (e) => { // do nothing if we didn't start selection if (!isSelecting.value) { return; } const pos = e.target.getStage().getPointerPosition(); selectionRectangle.x2 = pos.x; selectionRectangle.y2 = pos.y; }; const handleMouseUp = () => { // do nothing if we didn't start selection if (!isSelecting.value) { return; } isSelecting.value = false; // update visibility in timeout, so we can check it in click event setTimeout(() => { selectionRectangle.visible = false; }); const selBox = { x: Math.min(selectionRectangle.x1, selectionRectangle.x2), y: Math.min(selectionRectangle.y1, selectionRectangle.y2), width: Math.abs(selectionRectangle.x2 - selectionRectangle.x1), height: Math.abs(selectionRectangle.y2 - selectionRectangle.y1), }; const selected = rectangles.value.filter(rect => { // Check if rectangle intersects with selection box return Konva.Util.haveIntersection(selBox, getClientRect(rect)); }); selectedIds.value = selected.map(rect => rect.id); }; const handleDragEnd = (e, index) => { const rects = [...rectangles.value]; rects[index] = { ...rects[index], x: e.target.x(), y: e.target.y(), }; rectangles.value = rects; }; const handleTransformEnd = (e, index) => { const node = rectRefs.value[index].getNode(); const scaleX = node.scaleX(); const scaleY = node.scaleY(); node.scaleX(1); node.scaleY(1); const rects = [...rectangles.value]; rects[index] = { ...rects[index], x: node.x(), y: node.y(), width: Math.max(5, node.width() * scaleX), height: Math.max(node.height() * scaleY), rotation: node.rotation(), }; rectangles.value = rects; }; </script> Open on CodeSandboxOpen Sandbox

================================================================================


Selectors - KonvaJS Documentation
=================================

Source: https://konvajs.org/docs/selectors/Select_by_Name.html

To select shapes by name with Konva, we can use the find() method using the . selector. The find() method returns an array of nodes that match the selector string. VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; const stage = new Konva.Stage({ container: 'container', width: window.innerWidth, height: window.innerHeight, }); const layer = new Konva.Layer(); stage.add(layer); // create shapes with names const circle1 = new Konva.Circle({ x: 50, y: stage.height() / 2, radius: 30, fill: 'red', name: 'myCircle' }); const circle2 = new Konva.Circle({ x: 150, y: stage.height() / 2, radius: 30, fill: 'green', name: 'myCircle' }); const rect = new Konva.Rect({ x: 250, y: stage.height() / 2 - 25, width: 50, height: 50, fill: 'blue', name: 'myRect' }); layer.add(circle1); layer.add(circle2); layer.add(rect); // find all circles by name const circles = layer.find('.myCircle'); circles.forEach(circle => { // add animation to circles only circle.to({ duration: 1, rotation: 360, easing: Konva.Easings.EaseInOut }); }); Open on CodeSandboxOpen Sandboximport { Stage, Layer, Circle, Rect } from 'react-konva'; import { useEffect, useRef } from 'react'; const App = () => { const layerRef = useRef(null); useEffect(() => { // find all circles by name and animate them const circles = layerRef.current.find('.myCircle'); circles.forEach(circle => { circle.to({ duration: 1, rotation: 360, easing: Konva.Easings.EaseInOut }); }); }, []); return ( <Stage width={window.innerWidth} height={window.innerHeight}> <Layer ref={layerRef}> <Circle x={50} y={window.innerHeight / 2} radius={30} fill="red" name="myCircle" /> <Circle x={150} y={window.innerHeight / 2} radius={30} fill="green" name="myCircle" /> <Rect x={250} y={window.innerHeight / 2 - 25} width={50} height={50} fill="blue" name="myRect" /> </Layer> </Stage> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <v-stage :config="stageSize"> <v-layer ref="layerRef"> <v-circle :config="circle1Config" /> <v-circle :config="circle2Config" /> <v-rect :config="rectConfig" /> </v-layer> </v-stage> </template> <script setup> import { ref, onMounted } from 'vue'; import Konva from 'konva'; const stageSize = { width: window.innerWidth, height: window.innerHeight }; const circle1Config = { x: 50, y: window.innerHeight / 2, radius: 30, fill: 'red', name: 'myCircle' }; const circle2Config = { x: 150, y: window.innerHeight / 2, radius: 30, fill: 'green', name: 'myCircle' }; const rectConfig = { x: 250, y: window.innerHeight / 2 - 25, width: 50, height: 50, fill: 'blue', name: 'myRect' }; const layerRef = ref(null); onMounted(() => { // find all circles by name and animate them const circles = layerRef.value.getNode().find('.myCircle'); circles.forEach(circle => { circle.to({ duration: 1, rotation: 360, easing: Konva.Easings.EaseInOut }); }); }); </script> Open on CodeSandboxOpen Sandbox

================================================================================


Styling - KonvaJS Documentation
===============================

Source: https://konvajs.org/docs/styling/Fill.html

To fill a shape with Konva, we can set the fill property when we instantiate a shape, or we can use the fill() method. Konva supports colors, patterns, linear gradients, and radial gradients. Instructions: Mouseover each pentagon to change its fill. You can also drag and drop the shapes. VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; function loadImages(sources, callback) { var images = {}; var loadedImages = 0; var numImages = 0; // get num of sources for (var src in sources) { numImages++; } for (var src in sources) { images[src] = new Image(); images[src].onload = function () { if (++loadedImages >= numImages) { callback(images); } }; images[src].src = sources[src]; } } function draw(images) { var width = window.innerWidth; var height = window.innerHeight; var stage = new Konva.Stage({ container: 'container', width: width, height: height, }); var layer = new Konva.Layer(); var colorPentagon = new Konva.RegularPolygon({ x: 80, y: stage.height() / 2, sides: 5, radius: 70, fill: 'red', stroke: 'black', strokeWidth: 4, draggable: true, }); var patternPentagon = new Konva.RegularPolygon({ x: 220, y: stage.height() / 2, sides: 5, radius: 70, fillPatternImage: images.darthVader, fillPatternOffset: { x: -220, y: 70 }, stroke: 'black', strokeWidth: 4, draggable: true, }); var linearGradPentagon = new Konva.RegularPolygon({ x: 360, y: stage.height() / 2, sides: 5, radius: 70, fillLinearGradientStartPoint: { x: -50, y: -50 }, fillLinearGradientEndPoint: { x: 50, y: 50 }, fillLinearGradientColorStops: [0, 'red', 1, 'yellow'], stroke: 'black', strokeWidth: 4, draggable: true, }); var radialGradPentagon = new Konva.RegularPolygon({ x: 500, y: stage.height() / 2, sides: 5, radius: 70, fillRadialGradientStartPoint: { x: 0, y: 0 }, fillRadialGradientStartRadius: 0, fillRadialGradientEndPoint: { x: 0, y: 0 }, fillRadialGradientEndRadius: 70, fillRadialGradientColorStops: [0, 'red', 0.5, 'yellow', 1, 'blue'], stroke: 'black', strokeWidth: 4, draggable: true, }); /* * bind listeners */ colorPentagon.on('mouseover touchstart', function () { this.fill('blue'); }); colorPentagon.on('mouseout touchend', function () { this.fill('red'); }); patternPentagon.on('mouseover touchstart', function () { this.fillPatternImage(images.yoda); this.fillPatternOffset({ x: -100, y: 70 }); }); patternPentagon.on('mouseout touchend', function () { this.fillPatternImage(images.darthVader); this.fillPatternOffset({ x: -220, y: 70 }); }); linearGradPentagon.on('mouseover touchstart', function () { this.fillLinearGradientStartPoint({ x: -50 }); this.fillLinearGradientEndPoint({ x: 50 }); this.fillLinearGradientColorStops([0, 'green', 1, 'yellow']); }); linearGradPentagon.on('mouseout touchend', function () { // set multiple properties at once with setAttrs this.setAttrs({ fillLinearGradientStartPoint: { x: -50, y: -50 }, fillLinearGradientEndPoint: { x: 50, y: 50 }, fillLinearGradientColorStops: [0, 'red', 1, 'yellow'], }); }); radialGradPentagon.on('mouseover touchstart', function () { this.fillRadialGradientColorStops([ 0, 'red', 0.5, 'yellow', 1, 'green', ]); }); radialGradPentagon.on('mouseout touchend', function () { // set multiple properties at once with setAttrs this.setAttrs({ fillRadialGradientStartPoint: 0, fillRadialGradientStartRadius: 0, fillRadialGradientEndPoint: 0, fillRadialGradientEndRadius: 70, fillRadialGradientColorStops: [0, 'red', 0.5, 'yellow', 1, 'blue'], }); }); layer.add(colorPentagon); layer.add(patternPentagon); layer.add(linearGradPentagon); layer.add(radialGradPentagon); stage.add(layer); } var sources = { darthVader: 'https://konvajs.org/assets/darth-vader.jpg', yoda: 'https://konvajs.org/assets/yoda.jpg', }; loadImages(sources, function (images) { draw(images); }); Open on CodeSandboxOpen Sandboximport React from 'react'; import { Stage, Layer, RegularPolygon } from 'react-konva'; import useImage from 'use-image'; const commonProps = { sides: 5, radius: 70, stroke: 'black', strokeWidth: 4, draggable: true, }; const ColorPolygon = () => { const [fill, setFill] = React.useState('red'); return ( <RegularPolygon {...commonProps} x={80} y={window.innerHeight / 2} fill={fill} onMouseEnter={(e) => { setFill('blue'); e.target.getStage().container().style.cursor = 'pointer'; }} onMouseLeave={(e) => { setFill('red'); e.target.getStage().container().style.cursor = 'default'; }} /> ); }; const PatternPolygon = () => { const [darthVader] = useImage('https://konvajs.org/assets/darth-vader.jpg'); const [yoda] = useImage('https://konvajs.org/assets/yoda.jpg'); const [image, setImage] = React.useState(null); const [offset, setOffset] = React.useState({ x: -220, y: 70 }); React.useEffect(() => { if (darthVader) { setImage(darthVader); } }, [darthVader]); return ( <RegularPolygon {...commonProps} x={220} y={window.innerHeight / 2} fillPatternImage={image} fillPatternOffset={offset} onMouseEnter={(e) => { setImage(yoda); setOffset({ x: -100, y: 70 }); e.target.getStage().container().style.cursor = 'pointer'; }} onMouseLeave={(e) => { setImage(darthVader); setOffset({ x: -220, y: 70 }); e.target.getStage().container().style.cursor = 'default'; }} /> ); }; const LinearGradientPolygon = () => { const [colorStops, setColorStops] = React.useState([0, 'red', 1, 'yellow']); return ( <RegularPolygon {...commonProps} x={360} y={window.innerHeight / 2} fillLinearGradientStartPoint={{ x: -50, y: -50 }} fillLinearGradientEndPoint={{ x: 50, y: 50 }} fillLinearGradientColorStops={colorStops} onMouseEnter={(e) => { setColorStops([0, 'green', 1, 'yellow']); e.target.getStage().container().style.cursor = 'pointer'; }} onMouseLeave={(e) => { setColorStops([0, 'red', 1, 'yellow']); e.target.getStage().container().style.cursor = 'default'; }} /> ); }; const RadialGradientPolygon = () => { const [colorStops, setColorStops] = React.useState([0, 'red', 0.5, 'yellow', 1, 'blue']); return ( <RegularPolygon {...commonProps} x={500} y={window.innerHeight / 2} fillRadialGradientStartPoint={{ x: 0, y: 0 }} fillRadialGradientStartRadius={0} fillRadialGradientEndPoint={{ x: 0, y: 0 }} fillRadialGradientEndRadius={70} fillRadialGradientColorStops={colorStops} onMouseEnter={(e) => { setColorStops([0, 'red', 0.5, 'yellow', 1, 'green']); e.target.getStage().container().style.cursor = 'pointer'; }} onMouseLeave={(e) => { setColorStops([0, 'red', 0.5, 'yellow', 1, 'blue']); e.target.getStage().container().style.cursor = 'default'; }} /> ); }; const App = () => { return ( <Stage width={window.innerWidth} height={window.innerHeight}> <Layer> <ColorPolygon /> <PatternPolygon /> <LinearGradientPolygon /> <RadialGradientPolygon /> </Layer> </Stage> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <v-stage :config="stageSize"> <v-layer> <v-regular-polygon :config="{ x: 80, y: stageSize.height / 2, sides: 5, radius: 70, fill: colorFill, stroke: 'black', strokeWidth: 4, draggable: true, }" @mouseenter="onColorEnter" @mouseleave="onColorLeave" /> <v-regular-polygon :config="{ x: 220, y: stageSize.height / 2, sides: 5, radius: 70, fillPatternImage: patternImage, fillPatternOffset: patternOffset, stroke: 'black', strokeWidth: 4, draggable: true, }" @mouseenter="onPatternEnter" @mouseleave="onPatternLeave" /> <v-regular-polygon :config="{ x: 360, y: stageSize.height / 2, sides: 5, radius: 70, fillLinearGradientStartPoint: { x: -50, y: -50 }, fillLinearGradientEndPoint: { x: 50, y: 50 }, fillLinearGradientColorStops: linearGradientStops, stroke: 'black', strokeWidth: 4, draggable: true, }" @mouseenter="onLinearGradientEnter" @mouseleave="onLinearGradientLeave" /> <v-regular-polygon :config="{ x: 500, y: stageSize.height / 2, sides: 5, radius: 70, fillRadialGradientStartPoint: { x: 0, y: 0 }, fillRadialGradientStartRadius: 0, fillRadialGradientEndPoint: { x: 0, y: 0 }, fillRadialGradientEndRadius: 70, fillRadialGradientColorStops: radialGradientStops, stroke: 'black', strokeWidth: 4, draggable: true, }" @mouseenter="onRadialGradientEnter" @mouseleave="onRadialGradientLeave" /> </v-layer> </v-stage> </template> <script> export default { data() { return { stageSize: { width: window.innerWidth, height: window.innerHeight, }, colorFill: 'red', patternImage: null, patternOffset: { x: -220, y: 70 }, linearGradientStops: [0, 'red', 1, 'yellow'], radialGradientStops: [0, 'red', 0.5, 'yellow', 1, 'blue'], images: {}, }; }, mounted() { this.loadImages(); }, methods: { loadImages() { const sources = { darthVader: 'https://konvajs.org/assets/darth-vader.jpg', yoda: 'https://konvajs.org/assets/yoda.jpg', }; Object.keys(sources).forEach((name) => { const image = new Image(); image.onload = () => { this.images[name] = image; if (name === 'darthVader') { this.patternImage = image; } }; image.src = sources[name]; }); }, onColorEnter(e) { this.colorFill = 'blue'; e.target.getStage().container().style.cursor = 'pointer'; }, onColorLeave(e) { this.colorFill = 'red'; e.target.getStage().container().style.cursor = 'default'; }, onPatternEnter(e) { this.patternImage = this.images.yoda; this.patternOffset = { x: -100, y: 70 }; e.target.getStage().container().style.cursor = 'pointer'; }, onPatternLeave(e) { this.patternImage = this.images.darthVader; this.patternOffset = { x: -220, y: 70 }; e.target.getStage().container().style.cursor = 'default'; }, onLinearGradientEnter(e) { this.linearGradientStops = [0, 'green', 1, 'yellow']; e.target.getStage().container().style.cursor = 'pointer'; }, onLinearGradientLeave(e) { this.linearGradientStops = [0, 'red', 1, 'yellow']; e.target.getStage().container().style.cursor = 'default'; }, onRadialGradientEnter(e) { this.radialGradientStops = [0, 'red', 0.5, 'yellow', 1, 'green']; e.target.getStage().container().style.cursor = 'pointer'; }, onRadialGradientLeave(e) { this.radialGradientStops = [0, 'red', 0.5, 'yellow', 1, 'blue']; e.target.getStage().container().style.cursor = 'default'; }, }, }; </script> Open on CodeSandboxOpen Sandbox

================================================================================


Support - KonvaJS Documentation
===============================

Source: https://konvajs.org/docs/support.html

On this pageLooking for a help with Konva framework?​ Here is what you should do: First try to find solutions online. Try to search your question. You can use google, or built-in search on top of that page. The best place to ask questions is StackOverflow. You will have more chances to have a good answer if you create hight quality question with online demo, code samples, correct tags, etc. If you found a bug or you want to request a feature go to Issues Page. If you just want to discuss Konva you can join discord Chat If you have something interesting to share use Twitter #konvajs hashtag Visit Changelog to see what is changing. Need a consulting or strategy review? Go to Consulting Page

================================================================================


Svelte - KonvaJS Documentation
==============================

Source: https://konvajs.org/docs/svelte/index.html

How to use canvas with Svelte?​ svelte-konva is a JavaScript library for drawing complex canvas graphics using Svelte. GitHub: https://github.com/konvajs/svelte-konva It provides declarative and reactive bindings to the Konva Framework. All svelte-konva components correspond to Konva components of the same name. All the parameters available for Konva objects can be added as config prop for corresponding svalte-konva components. To get more info about Konva you can read Konva Overview. Quick Start​ 1 Install via npm​ npm i svelte-konva konva 2 Import and use svelte konva components​ <script> import { Stage, Layer, Rect } from 'svelte-konva';</script><Stage config={{ width: window.innerWidth, height: window.innerHeight }}> <Layer> <Rect config={{ x: 100, y: 100, width: 400, height: 200, fill: 'blue' }} /> </Layer></Stage>

================================================================================


Tools - KonvaJS Documentation
=============================

Source: https://konvajs.org/docs/tools.html

Konva + React Konva + Vue Konva + Svelte

================================================================================


Tweens - KonvaJS Documentation
==============================

Source: https://konvajs.org/docs/tweens/All_Controls.html

To control tweens with Konva, we can use the following methods: play() - Start or resume the tween pause() - Pause the tween reverse() - Reverse the tween direction reset() - Reset to initial state finish() - Jump to final state seek() - Jump to specific position Instructions: Use the buttons to control the tween animation of the circle. VanillaReactVueindex.htmlindex.jsimport Konva from 'konva'; const width = window.innerWidth; const height = window.innerHeight; const stage = new Konva.Stage({ container: 'container', width: width, height: height, }); const layer = new Konva.Layer(); const circle = new Konva.Circle({ x: 100, y: height / 2, radius: 70, fill: 'red', stroke: 'black', strokeWidth: 4, }); layer.add(circle); stage.add(layer); const tween = new Konva.Tween({ node: circle, duration: 2, x: width - 100, easing: Konva.Easings.EaseInOut, }); // create buttons const controls = ['play', 'pause', 'reverse', 'reset', 'finish']; controls.forEach(control => { const button = document.createElement('button'); button.textContent = control; button.addEventListener('click', () => { tween[control](); }); document.body.appendChild(button); }); // seek control const seekBtn = document.createElement('button'); seekBtn.textContent = 'Seek to 50%'; seekBtn.addEventListener('click', () => { tween.seek(1); // seek to 1 second }); document.body.appendChild(seekBtn); Open on CodeSandboxOpen Sandboximport { Stage, Layer, Circle } from 'react-konva'; import { useEffect, useRef } from 'react'; const App = () => { const circleRef = useRef(); const tweenRef = useRef(); useEffect(() => { if (!circleRef.current) return; tweenRef.current = new Konva.Tween({ node: circleRef.current, duration: 2, x: window.innerWidth - 100, easing: Konva.Easings.EaseInOut, }); }, []); const controls = ['play', 'pause', 'reverse', 'reset', 'finish']; return ( <> {controls.map(control => ( <button key={control} onClick={() => tweenRef.current[control]()} > {control} </button> ))} <button onClick={() => tweenRef.current.seek(1)}> Seek to 50% </button> <Stage width={window.innerWidth} height={window.innerHeight}> <Layer> <Circle ref={circleRef} x={100} y={window.innerHeight / 2} radius={70} fill="red" stroke="black" strokeWidth={4} /> </Layer> </Stage> </> ); }; export default App; Open on CodeSandboxOpen SandboxApp.vuemain.js<template> <div> <button v-for="control in controls" :key="control" @click="handleControl(control)" > {{ control }} </button> <button @click="handleSeek">Seek to 50%</button> <v-stage :config="stageSize"> <v-layer> <v-circle :config="circleConfig" ref="circleRef" /> </v-layer> </v-stage> </div> </template> <script setup> import { ref, onMounted } from 'vue'; import Konva from 'konva'; const stageSize = { width: window.innerWidth, height: window.innerHeight }; const circleConfig = { x: 100, y: window.innerHeight / 2, radius: 70, fill: 'red', stroke: 'black', strokeWidth: 4 }; const controls = ['play', 'pause', 'reverse', 'reset', 'finish']; const circleRef = ref(null); let tween = null; onMounted(() => { tween = new Konva.Tween({ node: circleRef.value.getNode(), duration: 2, x: window.innerWidth - 100, easing: Konva.Easings.EaseInOut, }); }); const handleControl = (control) => { tween[control](); }; const handleSeek = () => { tween.seek(1); }; </script> Open on CodeSandboxOpen Sandbox </rewritten_file>

================================================================================


Vue - KonvaJS Documentation
===========================

Source: https://konvajs.org/docs/vue/index.html

How to use canvas with Vue?​ Vue Konva is a JavaScript library for drawing complex canvas graphics using Vue. It provides declarative and reactive bindings to the Konva Framework. All vue-konva components correspond to Konva components of the same name with the prefix 'v-'. All the parameters available for Konva objects can be added as config in the prop for corresponding vue-konva components. Core shapes are: v-rect, v-circle, v-ellipse, v-line, v-image, v-text, v-text-path, v-star, v-label, v-path, v-regular-polygon. Also you can create custom shapes. To get more info about Konva you can read Konva Overview. Quick Start​ Vue.js version 3 is required. 1. Install via npm​ npm install vue-konva konva --save 2. Import and use VueKonva​ import { createApp } from 'vue';import App from './App.vue';import VueKonva from 'vue-konva';const app = createApp(App);app.use(VueKonva);app.mount('#app'); 3. Use in your components​ Instructions: Try to drag the stars. They will scale up while being dragged and return to normal size when released. App.vuemain.js<template> <v-stage ref="stage" :config="stageSize" @dragstart="handleDragstart" @dragend="handleDragend" > <v-layer ref="layer"> <v-star v-for="item in list" :key="item.id" :config="{ x: item.x, y: item.y, rotation: item.rotation, id: item.id, numPoints: 5, innerRadius: 30, outerRadius: 50, fill: '#89b717', opacity: 0.8, draggable: true, scaleX: dragItemId === item.id ? item.scale * 1.2 : item.scale, scaleY: dragItemId === item.id ? item.scale * 1.2 : item.scale, shadowColor: 'black', shadowBlur: 10, shadowOffsetX: dragItemId === item.id ? 15 : 5, shadowOffsetY: dragItemId === item.id ? 15 : 5, shadowOpacity: 0.6 }" /> </v-layer> </v-stage> </template> <script setup> import { ref, onMounted } from 'vue'; const stageSize = { width: window.innerWidth, height: window.innerHeight }; const list = ref([]); const dragItemId = ref(null); const handleDragstart = (e) => { // save drag element: dragItemId.value = e.target.id(); // move current element to the top: const item = list.value.find(i => i.id === dragItemId.value); const index = list.value.indexOf(item); list.value.splice(index, 1); list.value.push(item); }; const handleDragend = () => { dragItemId.value = null; }; onMounted(() => { for (let n = 0; n < 30; n++) { list.value.push({ id: Math.round(Math.random() * 10000).toString(), x: Math.random() * stageSize.width, y: Math.random() * stageSize.height, rotation: Math.random() * 180, scale: Math.random() }); } }); </script> Open on CodeSandboxOpen Sandbox Or use a CDN​ <html> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /> <meta http-equiv="x-ua-compatible" content="ie=edge" /> </head> <body> <div id="app"> <v-stage ref="stage" :config="configKonva"> <v-layer ref="layer"> <v-circle :config="configCircle" /> </v-layer> </v-stage> </div> <!--1. Link Vue Javascript & Konva--> <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script> <script src="https://unpkg.com/konva@9/konva.min.js"></script> <!--2. Link VueKonva Javascript (Plugin automatically installed)--> <script src="https://unpkg.com/vue-konva@3/dist/vue-konva.umd.js"></script> <script> // 3. Create the Vue instance const { createApp, ref } = Vue; const VueKonva = window['vue-konva'].default; const app = createApp({ setup() { const configKonva = { width: 200, height: 200 }; const configCircle = { x: 100, y: 100, radius: 70, fill: 'red', stroke: 'black', strokeWidth: 4 }; return { configKonva, configCircle }; } }); app.use(VueKonva); app.mount('#app'); </script> </body></html>

================================================================================

